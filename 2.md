# C++11
---

## non-static data member initializers (NSDMI)

Det er nå mulig å initialisere medlemsvariable i klasse-definisjonen:

```cpp
class S { 
  int a = 0;
  int* p = nullptr;
  std::array<int, 3> ar{1, 2, 3};
  std::vector<int> v{ 1, 2 };
  
  S(int a, std::array<int, 3> art) : a(a), ar(art) {}
};

Det er mye enklere å få oversikt, og man er sikker på at variabelen ikke er uinitialisert.
```

http://en.cppreference.com/w/cpp/language/data_members
---

## move semantics

Move semantics er nytt i C++11. Prinsippet er at det skal være mulig å "stjele" data i stedet for å måtte kopiere:

```cpp
struct vector {
  char* buf = nullptr;
  size_t capacity = 0;
}

vector a;

a.buf = peker_til_digert_minnesegment
a.capacity = 100
```

Hvis vi nå skal kopiere *a* må vi kopiere hele minnesegmentet, og det kan være kostbart. I C++11 har vi derfor muligheten til å "stjele" minnesegmentet (overta *buf* og *capacity*, og sette *a* sin *buf* til **nullptr** og *capacity* til **0**).

---

## move semantics : return-by-value

Det meste av move semantics er for å vite når vi kan "stjele" fra objektet, og når vi ikke kan det. I tillegg er det en del typer som kun er mulig å flytte - ikke kopiere - som f.eks *unique_ptr*. Med flytting er det ikke lenger kostbart å returnere f.eks en diger vector fra en funksjon, siden den flyttes i stedet for å kopieres.

```cpp
std::vector<std::string> func()
{
  std::vector<std::string> vec;
  // .. fyll med 1000 000 elementer
  return vec;
}

auto elements = func();
```

Det er derfor svært liten grunn for å fortsette å bruke out-variable i funksjoner.


---

## move semantics : move og rvalue references

For å signalisere at et objekt kan flyttes når vi sender det fra oss, bruker vi `move`. For å vite om et objekt kan flyttes når det kommer fra et annet sted, bruker vi rvalue references (`&&`). 

```cpp
class A {
  std::string enlangtekst;
public:
  A(const A&) = delete; // Fjern copy constructor
  A(A&&) = default; // Bruk standard move constructor
};
```

```cpp
class A {
  std::string enlangtekst;
public:
  A(const A&) = delete; // Fjern copy constructor
  A(A&& other) {
*    this->enlangtekst = std::move(other.enlangtekst);
  }
};
```
Hvis vi skriver move-constructoren selv, kan den f.eks se ut som over. Da får assignment-operatoren til `std::string` (`std::string& operator=( string_type )`) en `std::string&&` i stedet for en `const std::string&` - og da vet vi at vi trygt kan "stjele" innholdet.
